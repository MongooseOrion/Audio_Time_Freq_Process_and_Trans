<!-- =====================================================================
* Copyright (c) 2023, MongooseOrion.
* All rights reserved.
*
* The following code snippet may contain portions that are derived from
* OPEN-SOURCE communities, and these portions will be licensed with: 
*
* <NULL>
*
* If there is no OPEN-SOURCE licenses are listed, it indicates none of
* content in this Code document is sourced from OPEN-SOURCE communities. 
*
* In this case, the document is protected by copyright, and any use of
* all or part of its content by individuals, organizations, or companies
* without authorization is prohibited, unless the project repository
* associated with this document has added relevant OPEN-SOURCE licenses
* by github.com/MongooseOrion. 
*
* Please make sure using the content of this document in accordance with 
* the respective OPEN-SOURCE licenses. 
* 
* THIS CODE IS PROVIDED BY https://github.com/MongooseOrion. 
* FILE ENCODER TYPE: GBK
* ========================================================================
-->
# 回声消除、去噪、音色调整和声纹识别的原理

## 回声消除原理

由于声波在传播过程中遇到了墙壁或其他障碍物而反射，会导致回声影响。当录制音频时，这种反射会被同时记录下来，导致原始声音与回声的重叠。通过引入一定程度的信号延迟，并通过信号加权相减的方式可以消除延迟引起的回声。

具体而言，可以采用一种简单的线性加权相减方式，信号输出函数如下述公式所示：

$$y(n)=x(n) - \alpha x(n-N)$$

其中， $x(n)$ 表示序列索引为 $n$ 的量化数据， $\alpha$ 表示权重系数， $N$ 表示延迟样本数（窗口样本）。

上述公式通过引入延迟并进行加权相减的处理，尽量减少了原始信号与延迟信号之间的重叠，从而减少了回声的影响。

## 音色调整原理

在进行人声调整时，人声的基音频率是一个重要的参数。在频域分析中，基音频率和其谐波通常会在频谱图中呈现为峰值。这些峰值对应于声音信号中不同频率成分的能量。基音频率对应于声谱图中的第一个主要峰值，而其他谐波对应于较高的峰值，其频率是基音频率的整数倍。

男性的声音通常具有较低的基音频率，而女性的声音则具有较高的基音频率。通过增加声音的基音频率，可以使男性声音听起来更像女性声音；通过减小声音的基音频率，可以使女性声音听起来更像男性声音。这通常是通过改变基音周期来实现，可分别在时域和频域进行处理。

如果选择在时域处理，可对输入序列强制重采样。例如给定带有特征输入序列样本数为 1024，按照某种抽样方法抽取样本数为 768，采样率维持原样，则可以提升特征频率。由于样本数变少，为了保持采样率不变，需要应用某种算法复制重采样后的序列部分或全部样本，那么在相同的时间宽度内原序列和采样后的序列将拥有相同的样本数量，如下图所示。一般而言，由于采样的不确定性和噪声，抽样后相近的样本之间幅值可能存在剧烈变化，这样会使音频不够自然和平滑。为解决该问题，可选取当前抽样样本与其前几个样本的均值作为新的采样样本，这样可抑制样本幅值变化剧烈导致的齿音等不良影响，获得变化平滑的序列。

<div align = 'center'><img src='../Document\pic\绘图6.png' height = '300' title = '时域降采样和插值方法示意'></div>

如果在频域处理，则可以利用在频域上进行频谱搬移来实现变声。频谱搬移是将频谱图在频率轴上向高频或低频方向移动一定的距离。移动频谱的距离通常由变声的目标决定。这个移动可以通过在频域上对快速傅里叶变换（FFT）结果进行平移操作来实现。如果将频谱向高频方向移动，则基音频率将增加，声音听起来会更高音调。反之，如果将频谱向低频方向移动，则基音频率将减小，声音听起来会更低音调。

时域上的抽样方法简单直观，计算速度快，但可能会导致声音质量损失；而频域上的频谱搬移方法保留了频谱信息，变声效果较好，但计算复杂度较高，实现难度较大。

## 去除背景声和多重声音分离原理

*本文档仅讨论对某一给定音频的 FPGA 处理方法，而不涉及自适应降噪方法。*

去噪和声音分离的基本原理是抑制频域中的某些频率成分的幅值，和（或）提升某些频率成分的幅值。然而在 FPGA 流式处理的过程中，如果 FFT 窗口宽度与滑动步长相同，也即每次处理的批数据两两均无重叠，则输出的声音可能会有咔哒声，这是因为每次处理的数据流都是孤立的，那么在频域进行处理后反傅里叶变换时前一段序列与后一段序列间不是平滑变化的，而是呈现出峰值。为了使得流式处理时音频是平滑、连续的，滑动处理的步长应当小于 FFT 窗口宽度，例如 $\frac{1}{2}$ ，如下图所示。特别的，在 FPGA 处理时，如果将滑动处理的步长设置为 FFT 窗口宽度一半，则可以以较小的算法复杂度重建出原始信号。

<div align = 'center'><img src='../Document\pic\绘图1.png' height = '270' title = '时域音频信号加窗和滑窗方式示意图'></div>

为简化在 FPGA 上处理重叠 FFT 的部分，可以在傅里叶正变换（FFT）前和傅里叶逆变换（iFFT）之后分别应用正弦窗函数。这是因为正弦窗乘以正弦窗等于应用汉宁窗（对同一信号应用两次正弦窗），而应用汉宁窗的两组数据若恰好有一半的样本重叠，则重叠的部分相加恒等于 1，所以对于前后两次滑动处理的数据（它们滑动处理的步长必须为 FFT 窗口宽度的一半），如果在 FFT 之前和 iFFT 之后分别应用正弦窗，然后再对两组数据 iFFT 变换后重叠的序列的幅值相加，即可重建出原始信号。

<div align = 'center'><img src ='./pic\绘图7.png' width='550px' title='重叠信号处理原理图'></div>

利用该原理，应用于在频谱上进行去噪和多重声音处理的前后，那么恢复的时域信号将能呈现出更好的清晰度和保真度。

对于给定任一音频，去噪和声音分离都需要找到多重声音在频域的对应频率分量，并在时域上进行抑制或提取处理。由于音频在时间上呈现出连续性，因此音频中多重声音的频率分量和幅值在时域上可能存在较大变化。在这种情况下，将音频中某一时段进行频域分析获得的不同声音的频率分量作为处理基准并对整段音频应用此配置，则算法正常工作的可能性不大。

为解决该问题，可以将音频在时域上分为多个处理段，每段音频处理段应用对应的频率抑制和提取配置，这意味着在流式处理时需要准确识别出音频的起始帧，并在接下来的时间按顺序执行每一时间段的处理配置。然而，对于 FPGA 处理而言，音频来临的时间是未知的，在音频来临之前只有噪声，如果将某一噪声样本识别为音频的起始帧并加以处理，则会引发处理错误。

环境噪声一般幅值是比较平均的，并且幅值应当远小于测试音频，基于此，可以设置幅度阈值来作为噪声或测试音频来临的判定标准。然而，仅仅使用一个固定的幅度阈值作为判定标准在输出音量可变时则会变得不太可用，因为当输出音量设置为较大值时噪声和测试音频的幅值都会呈现出更高的幅值（相比于输出音量较小时）。此时，可以使用一些基于统计学概念的方法，例如：统计在某一段时间内，音频幅值穿过参考电平的次数与总序列值的比值。由于环境噪声的幅值在任意时间段内穿过参考电平的值应该是较为平均的，而测试音频应该与环境噪声的值有一个明显的差异，因此通过测算一个能明显区分测试音频与环境噪声的穿过参考电平的次数阈值并在 FPGA 中应用，是有效的。

## 声纹识别

实现声纹识别需要经过两个阶段：训练和识别。这两个阶段的核心都是对音频样本进行矢量量化（VQ，Vector Quantization），在对音频样本训练阶段，VQ 用于将特征参数进行分类，产生不同码矢所对应的码本。在识别阶段，VQ 用于计算平均失真测度，从而实现声纹识别。

### VQ 算法描述

VQ 问题可以描述为：给定一个已知统计属性的矢量源（也就是训练样本集，每一个样本是一个矢量）和一个失真测度。还给定了码矢的数量（也就是要把这个矢量空间划分为多少部分，或者说量化为多少种值），然后寻找一个具有最小平均失真度（数据压缩，肯定是失真越小越好）的码书（所有码矢的集合，也就是上面的那些所有红色星星点）和空间的划分。

假定给定一个有 $M$ 个矢量源（训练样本）的训练序列（训练集）：

$$\mathbf{T}={\mathbf{x_1}, \mathbf{x_2},\dots , \mathbf{x_M}}$$

这个训练序列可以通过一些大数据库得到。例如如果这个矢量源是语音的话，那么可以对一些电话录音裁剪得到每个源矢量 $\mathbf{x_m}$。设 $\mathbf{x_m}$ 是 $k$ 维的，则有：

$$\mathbf{x_m}=(x_{m,1}, x_{m,2}, \dots, x_{m,k}),\quad m=1,2,\dots, M$$

假设码矢的数目是 $N$（也就是要把这个矢量空间划分为 $N$ 个部分，或者说量化为 $N$ 种值），码书（所有码矢的集合）表示为：

$$\mathbf{C}={\mathbf{c_1}, \mathbf{c_2},\dots , \mathbf{c_N}}$$

其中，每一个码矢 $\mathbf{c_n}$ 是个 $k$ 维向量：

$$\mathbf{c_n}=(c_{n,1}, c_{n,2}, \dots, c_{n,k}),\quad n=1,2,\dots ,N$$

与码矢 $\mathbf{c_n}$ 对应的编码区域表示为 $\mathbf{S_n}$ ，然后将空间的划分表示为：

$$\mathbf{P}={\mathbf{S_1}, \mathbf{S_2},\dots ,\mathbf{S_N}}$$

如果源矢量 $\mathbf{x_m}$ 在 $\mathbf{S_n}$ 内，那么它的近似表示就是 $\mathbf{c_n}$ ，记为：

$$Q(\mathbf{x_m})= \mathbf{c_n}, \quad \text{if}\ \mathbf{x_m} \in \mathbf{S_n}$$

若采用均分误差失真度量，那么平均失真度可表示为：

$$D_{\text{avg}} = \frac{1}{Mk}\sum_{m=1}^{M}|| \mathbf{x_m}-Q(\mathbf{x_m})||^2$$

令 $\mathbf{e} = \mathbf{x_m}-Q(\mathbf{x_m})$ ，则称 $|| \mathbf{e} ||^2$ 为欧氏几何距离。

求解码书 $\mathbf{C}$ 和空间划分 $\mathbf{P}$ 需要满足两个优化条件：

（1）**最近邻条件**：编码区域 $\mathbf{S_n}$ 应该包含所有与 $\mathbf{c_n}$ 最接近的矢量（相比于与其他码矢的距离）。对于在边界上面的矢量，需要采用一些决策方法。

（2）**质心条件**：要求码矢 $\mathbf{c_n}$ 是编码区域 $\mathbf{S_n}$ 内所有的训练样本向量的平均向量。在实现中，需要保证每个编码区域至少要有一个训练样本向量。

### LBG 方法描述

LBG 是一种 VQ 的迭代算法，它交替地调整 $\mathbf{P}$ 和 $\mathbf{C}$ ，使失真度不断地趋向于它的局部最小值。这个算法需要一个初始的码书 $C^{(0)}$ 。初始码书可以通过分裂方法得到，该方法主要是把一个初始码矢设置为所有训练样本的平均值，然后把这个码矢分裂成两个，把这两个码矢作为初始的码书，然后基于初始码书开始迭代。它每一次都将每个码矢分裂为 2 个，重复这个过程，直到获得要求的码矢个数。1 个分裂为 2 个，2 个分裂为 4 个，4 个分裂为 8 个 …… 

设置较高的码矢个数可以获得更好的精确度，设置较少的码矢个数可以降低计算复杂度，在确定码矢个数时应该平衡精确度和计算复杂度，可以在实际的算法流程中确定码矢的个数。此项目设置为 8。

LBG 算法流程如下：

1. 给定训练集 $\mathbf{T}$ 。设置失真阈值 $\varepsilon$ 为一个很小的正数，此项目设置为 0.02。

2. 先初始化码矢数量 $N = 1$ ，将这一个码矢设置为所有训练样本的平均值：

$$\mathbf{c_1^*} = \frac{1}{M}\sum_{m=1}^{M}\mathbf{x_m}$$

计算当前的总失真度：

$$D_{\text{avg}}^{*} = \frac{1}{Mk}\sum_{m=1}^{M}|| \mathbf{x_m}-\mathbf{c_1^*}||^2$$

3. 使用分裂方法，对于 $i=1,2,\dots,N$ ，它们的码矢分别为：

$$\begin{align*}
\mathbf{c_i^{(0)}} &= (1+\varepsilon) \mathbf{c_i^*},\\
\mathbf{c_{N+i}^{(0)}} &= (1-\varepsilon) \mathbf{c_i^*}
\end{align*}$$

每个码矢分裂（乘以扰乱系数 $1+\varepsilon$ 和 $1-\varepsilon$ ）为两个，每一次分裂后的码矢数量就是前一次的两倍。

4. 迭代。令初始失真度为： $D_{\text{avg}}^{(0)} = D_{\text{avg}}^*$ ，将迭代索引或者迭代计数器置零 $i=0$ 。

（1）对于训练集 T 中的每一个训练样本 $m=1,2,…,M$ 。在所有码矢中寻找 $||\mathbf{x_m}-\mathbf{c_n^{(i)}}||^2$ 的最小值，也就是看这个训练样本和哪个码矢距离最近，然后将这个样本加入到集合 $\mathbf{S_n}$ 中。

（2）对于 $n=1,2,\dots,N$ ，通过以下方式更新所有码矢：

$$\mathbf{c_{n}^{i+1}} = \frac{\sum_{Q({\mathbf{x_m}}) = \mathbf{c_n^{(i)}}}\mathbf{x_m}}{\sum_{Q({\mathbf{x_m}}) = \mathbf{c_n^{(i)}}}1}$$

即将所有属于 $\mathbf{c_n}$ 所在的编码区域 $\mathbf{S_n}$ 的训练样本取平均作为这个编码区域的新的码矢。

（3）迭代计数器加 1： $i=i+1$ 。

（4）计算在现阶段的 $\mathbf{C}$ 和 $\mathbf{P}$ 基础上的总失真度：

$$D_{\text{avg}}^{i} = \frac{1}{Mk}\sum_{m=1}^{M}|| \mathbf{x_m}-Q(\mathbf{x_m})||^2$$

（5）如果失真度相比上一次的失真度（相对失真改进量）大于预设的失真阈值 $\varepsilon$ ，则基于当前码矢继续迭代，返回步骤（1）。

$$\frac{D_{\text{avg}}^{i-1}-D_{\text{avg}}^{i}}{D_{\text{avg}}^{i-1}} > \varepsilon$$

否则最终失真度为 $D_{\text{avg}}^{*}=D_{\text{avg}}^{i}$ ，对于 $n=1,2,\dots,N$ ，最终码矢为 $\mathbf{c_n^*}=\mathbf{c_n^{(i)}}$ 。

6. 重复步骤 3 和 4 至到码矢的数目达到要求的个数。

### 特征参数提取

在利用 VQLBG 算法对音频特征训练和识别之前，首先需要对输入音频序列进行特征提取。梅尔倒谱系数（Mel-scaleFrequency Cepstral Coefficients，MFCC）是一种较为常用的语音特征参数。

MFCC 参数是基于人的听觉特性利用人听觉的屏蔽效应，在 Mel 标度频率域提取出来的倒谱特征参数。人耳对不同频率的声波有不同的听觉敏感度，因此从低频到高频这一段频带内按临界带宽的大小由密到疏安排一组带通滤波器，对输入信号进行滤波。将每个带通滤波器输出的信号能量作为信号的基本特征，对此特征经过进一步处理后就可以作为语音的输入特征。

#### 梅尔滤波器简介

梅尔频率 $F_{\text{mel}}$ 与实际频率 $f$ 的函数关系为：

$$F_{\text{mel}}(f) = 1125\ln(1+\frac{f}{700})$$

一般设置梅尔滤波器的组数在 20-24 个，此项目设置为 $M=31$ 个。设滤波器频率范围内的最低频率 $f_l = 0\text{Hz}$ ，滤波器频率范围内的最高频率 $f_h=24\text{kHz}$ （受限奈奎斯特采样定理，最高是采样频率的一半），FFT 时的长度 $N=1024$ ，采样频率 $f_s=48\text{kHz}$ ，则可将 $F_{\text{mel}}(f_l)$ 到 $F_{\text{mel}}(f_h)$ 的 Mel 频率范围均分为 $m+1=32$ 段，产生 $M+2=22$ 个 Mel 频率值，则 33 个 Mel 频率值可用下述公式计算：

$$F_{mel}(i) = F_{\text{mel}}(f_l) + i\frac{F_{\text{mel}}(f_h)-F_{\text{mel}}(f_l)}{M+1},\quad i=0,1,\dots, 32$$

则对应的实际频率值可用下述公式计算：

$$f(i) = F_{\text{mel}}^{-1}(F_{\text{mel}}(f_l) + i\frac{F_{\text{mel}}(f_h)-F_{\text{mel}}(f_l)}{M+1}),\quad i=0,1,\dots, 32$$

其中， $F_{\text{mel}}^{-1}(b) = 700(e^{b/1125}-1)$ 。

梅尔滤波器的频率响应定义为：

$$H_m(k)=\begin{cases}
0, \quad k < f(m-1)\\
\frac{k-f(m-1)}{f(m)-f(m-1)}, \quad f(m-1) \le k \le f(m) \\
\frac{f(m+1) - k}{f(m+1)-f(m)}, \quad f(m) \le k \le f(m+1) \\
0, \quad k > f(m+1)
\end{cases}$$

其中， $f(m) = (N/f_s)f(i)$ 为滤波器中心频率对应的 FFT 序列索引（向上取整）， $k$ 为 FFT 序列索引。

<div align='center'><img src='./pic\绘图11.png' width='450'></div>

#### MFCC 参数计算

1. 对输入信号预加重、加窗、分帧、FFT，其中预加重处理是将语音信号通过一个高通滤波器：

$$H(z)=1-\mu z^{-1}$$

其中 $\mu=0.9\sim1$ ，通常取为 0.97。预加重的目的是提升高频部分，使信号的频谱变得平坦，保持在低频到高频的整个频带中，能用同样的信噪比求频谱。同时，也是为了消除发生过程中声带和嘴唇的效应，来补偿语音信号受到发音系统所抑制的高频部分，也为了突出高频的共振峰。

2. 求频谱能量谱（幅度平方）。

3. 将能量谱通过一组 mel 滤波器组，然后计算组内每个 mel 滤波器输出的对数能量：

$$S(m)=\ln(\sum_{k=1}^{N-1}|X_a(k)|^2 H_m(k))$$

其中，

$$X_a(k) = \sum_{n=1}^{N-1}x(n)e^{-\frac{j2\pi nk}{N}}, \quad 0\le k \le N-1$$

为信号经过 FFT 变换后的频谱函数， $N$ 为傅里叶窗口样本数。

4. 经过离散余弦变换得到 MFCC 系数：

$$C(n)=\begin{cases}
\sum_{m=0}^{M-1}\sqrt{\frac{1}{M}} S(m)\cos(\frac{n\pi(m+0.5)}{M}), \quad n=0\\
\sum_{m=0}^{M-1}\sqrt{\frac{2}{M}} S(m)\cos(\frac{n\pi(m+0.5)}{M}), \quad n\ne 0\\
\end{cases}\\ n = 0,1,\dots, M-1$$

